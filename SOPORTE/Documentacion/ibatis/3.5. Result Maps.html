<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>3.5.&nbsp;Result Maps</title><link rel="stylesheet" href="3.5.%C2%A0Result%20Maps%20Archivos/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="https://ibatis.apache.org/docs/dotnet/datamapper/index.html" title="iBATIS.NET - DataMapper Application Framework"><link rel="up" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03.html" title="Chapter&nbsp;3.&nbsp;Working with Data Maps"><link rel="prev" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03s04.html" title="3.4.&nbsp;Parameter Maps and Inline Parameters"><link rel="next" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03s06.html" title="3.6.&nbsp;Supported Types for Parameter Maps and Result Maps"><link rel="copyright" href="https://ibatis.apache.org/docs/dotnet/datamapper/ln-id368653.html" title="Legal Notice"></head><body alink="#0000FF" link="#0000FF" text="black" vlink="#840084" bgcolor="white"><div class="navheader"><table summary="Navigation header" width="100%"><tbody><tr><th colspan="3" align="center">3.5.&nbsp;Result Maps</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03s04.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;3.&nbsp;Working with Data Maps</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03s06.html">Next</a></td></tr></tbody></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id381495"></a>3.5.&nbsp;Result Maps</h2></div></div></div><p>Section 3.4 describes Parameter Maps and Inline parameters, which
    map object properties to parameters in a database query. Result Maps
    finish the job by mapping the result of a database query (a set of
    columns) to object properties. Next to Mapped Statements, the Result Map
    is probably one of the most commonly used and most important features to
    understand.</p><p>A Result Map lets you control how data is extracted from the result
    of a query, and how the columns are mapped to object properties. A Result
    Map can describe the column type, a null value replacement, and complex
    property mappings including Collections. Example 3.24 shows the structure
    of a &lt;resultMap&gt; element.</p><div class="example"><a name="id381524"></a><p class="title"><b>Example&nbsp;3.26.&nbsp;The structure of a &lt;resultMap&gt; element.</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMap id="<span class="blue">resultMapIdentifier</span>" 
           [class="<span class="blue">fullyQualifiedClassName, assembly|typeAlias</span>"] 
           [extends="<span class="blue">[sqlMapNamespace.]resultMapId</span>"]&gt;

   &lt;constructor &gt; 
       &lt;argument property="<span class="blue">argumentName</span>" 
           column="<span class="blue">columnName</span>"
           [columnIndex="<span class="blue">columnIndex</span>"] 
           [dbType="<span class="blue">databaseType</span>"] 
           [type="<span class="blue">propertyCLRType</span>"]
           [resultMapping="<span class="blue">resultMapName</span>"]
           [nullValue="<span class="blue">nullValueReplacement</span>"] 
           [select="<span class="blue">someOtherStatementName</span>"] 
           [typeHandler="<span class="blue">fullyQualifiedClassName, assembly|typeAlias</span>"] /&gt;
   &lt;/constructor &gt; 

   &lt;result property="<span class="blue">propertyName</span>" 
           column="<span class="blue">columnName</span>"
           [columnIndex="<span class="blue">columnIndex</span>"] 
           [dbType="<span class="blue">databaseType</span>"] 
           [type="<span class="blue">propertyCLRType</span>"]
           [resultMapping="<span class="blue">resultMapName</span>"]
           [nullValue="<span class="blue">nullValueReplacement</span>"] 
           [select="<span class="blue">someOtherStatementName</span>"] 
           [lazyLoad="<span class="blue">true|false</span>"]
           [typeHandler="<span class="blue">fullyQualifiedClassName, assembly|typeAlias</span>"]
   /&gt;
   &lt;result ... .../&gt;
   &lt;result ... .../&gt;
   <span class="comment"> // Inheritance support</span>
   &lt;discriminator column="<span class="blue">columnName</span>" 
                     [type|typeHandler="<span class="blue">fullyQualifiedClassName, assembly|typeAlias</span>"]
   /&gt;
    &lt;subMap value="<span class="blue">discriminatorValue</span>" 
               resultMapping="<span class="blue">resultMapName</span>"
   /&gt;
   &lt;subMap .../&gt; 
&lt;/resultMap&gt;
</pre></div></div><p><br class="example-break">In Example 3.24, the [brackets] indicate optional attributes.
    The <em class="parameter"><code>id</code></em> attribute is required and provides a name
    for the statement to reference. The class attribute is also required, and
    specifies a Type Alias or the fully qualified name of a class. This is the
    class that will be instantiated and populated based on the result mappings
    it contains.</p><p>The resultMap can contain any number of property mappings that map
    object properties to the columns of a result element. The property
    mappings are applied, and the columns are read, in the order that they are
    defined. Mainting the element order ensures consistent results between
    different drivers and providers. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="3.5.%C2%A0Result%20Maps%20Archivos/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>As with parameter classes, the result class must be a .NET
        object or IDictionary instance.</p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id381738"></a>3.5.1.&nbsp;Extending resultMaps</h3></div></div></div><p>The optional extends attribute can be set to the name of another
      resultMap upon which to base this resultMap. All properties of the
      "super" resultMap will be included as part of this resultMap, and values
      from the "super" resultMap are set before any values specified by this
      resultMap. The effect is similar to extending a class.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Tip" border="0"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="3.5.%C2%A0Result%20Maps%20Archivos/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The "super" resultMap must be defined in the file
          <span class="emphasis"><em>before</em></span> the extending resultMap. The classes for
          the super and sub resultMaps need not be the same, and do not need
          to be related in any way.</p></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id381775"></a>3.5.2.&nbsp;&lt;resultMap&gt; attributes</h3></div></div></div><p>The &lt;resultMap&gt; element accepts three attributes:
      <em class="parameter"><code>id</code></em> (required), <em class="parameter"><code>class</code></em>
      (optional), and <em class="parameter"><code>extends</code></em> (optional).</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id381800"></a>3.5.2.1.&nbsp;id</h4></div></div></div><p>The required <em class="parameter"><code>id</code></em> attribute provides a
        unique identifier for the &lt;resultMap&gt; within this Data
        Map.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id381818"></a>3.5.2.2.&nbsp;class</h4></div></div></div><p>The optional <em class="parameter"><code>class</code></em> attribute specifies an
        object class to use with this &lt;resultMap&gt;. The full classname or
        an alias must be specified. Any class can be used.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="3.5.%C2%A0Result%20Maps%20Archivos/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>As with parameter classes, the result classes must be a .NET
            object or IDictionary instance.</p></td></tr></tbody></table></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id381850"></a>3.5.2.3.&nbsp;extends</h4></div></div></div><p>The optional <em class="parameter"><code>extends</code></em> attribute allows the
        result map to inherit all of the properties of the "super" resultMap
        that it extends.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id381867"></a>3.5.2.4.&nbsp;groupBy</h4></div></div></div><p>The optional <em class="parameter"><code>groupBy</code></em>
 attribute specifies a list of .NET property names of the result object 
build by the resultMap. They are used to identify unique rows in the 
returned result set. Rows with equal values for the specified properties
 will only generate one result object. Use groupBy in combination with 
nested resultMaps to solve the N+1 query problem. Exemple : "Id" or 
"Desciption, Date".(see  paragraph 3.5.13).</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id381890"></a>3.5.3.&nbsp;&lt;constructor&gt; element</h3></div></div></div><p>The
 &lt;constructor&gt; element must match the signature of one of the 
result class constructor. If specify, this element is used by iBATIS to 
instanciate the result object.</p><p>The &lt;constructor&gt; element holds one or more &lt;argument&gt;
      child elements that map SQL resultsets to object argument constructor.</p><p>
        </p><div class="example"><a name="id381919"></a><p class="title"><b>Example&nbsp;3.27.&nbsp;Constructor element example</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMap id="account-result-constructor" class="Account" &gt;
	 <span class="blue">&lt;constructor&gt;
		&lt;argument argumentName="id" column="Account_ID"/&gt;
		&lt;argument argumentName="firstName" column="Account_FirstName"/&gt;
		&lt;argument argumentName="lastName" column="Account_LastName"/&gt;
	&lt;/constructor&gt;</span>
	&lt;result property="EmailAddress" column="Account_Email" nullValue="no_email@provided.com"/&gt;
	&lt;result property="BannerOption" column="Account_Banner_Option" dbType="Varchar" type="bool"/&gt;
	&lt;result property="CartOption"	column="Account_Cart_Option" typeHandler="HundredsBool"/&gt;
&lt;/resultMap&gt;</pre></div></div><p><br class="example-break">
		</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id381950"></a>3.5.3.1.&nbsp;argumentName</h4></div></div></div><p>The <em class="parameter"><code>argumentName</code></em> attribute is the name of a
        constructor argument of the result object that will be returned by the Mapped
        Statement.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id381968"></a>3.5.3.2.&nbsp;column</h4></div></div></div><p>The <em class="parameter"><code>column</code></em> attribute value is the name of
        the column in the result set from which the value will be used to
        populate the argument.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id381985"></a>3.5.3.3.&nbsp;columnIndex</h4></div></div></div><p>As an optional (minimal) performance enhancement, the
        <em class="parameter"><code>columnIndex</code></em> attribute value is the index of the
        column in the ResultSet from which the value will be used to populate
        the object argument. This is not likely needed in 99% of applications
        and sacrifices maintainability and readability for speed. Some
        providers may not realize any performance benefit, while others will
        speed up dramatically.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382007"></a>3.5.3.4.&nbsp;dbType</h4></div></div></div><p>The dbType attribute is used to explicitly specify the database
        column type of the ResultSet column that will be used to populate the
        argument. Although Result Maps do not have the same
        difficulties with null values, specifying the type can be useful for
        certain mapping types such as Date properties. Because an application
        language has one Date value type and SQL databases may have many
        (usually at least 3), specifying the date may become necessary in some
        cases to ensure that dates (or other types) are set correctly.
        Similarly, String types may be populated by a VarChar, Char or CLOB,
        so specifying the type might be needed in those cases too.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382018"></a>3.5.3.5.&nbsp;type</h4></div></div></div><p>The type attribute is used to explicitly specify the CLR
        argument type. Normally this can be derived
        from a argument through reflection, but certain mappings that use
        objects such as a Map cannot provide the type to the framework. If the
        attribute type is not set and the framework cannot otherwise determine
        the type, the type is assumed to be Object. Section 6 details the CLR
        types and available aliases that are supported by the
        framework.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382038"></a>3.5.3.6.&nbsp;resultMapping</h4></div></div></div><p>The <em class="parameter"><code>resultMapping</code></em> attribute can be set to
        the name of another resultMap used to fill the argument. If the
        resultMap is in an other mapping file, you must specified the fully
        qualified name.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382053"></a>3.5.3.7.&nbsp;nullValue</h4></div></div></div><p>The <em class="parameter"><code>nullValue</code></em> attribute can be set to any
        valid value (based on argument type). The result element's
        <em class="parameter"><code>nullValue</code></em> attribute is used to specify an
        inbound null value replacement. What this means is that when the value
        is detected in a query's result column, the corresponding object
        argument will be set to the the <em class="parameter"><code>nullValue</code></em>
        attribute's value. This allows you to use a "magic" null number in
        your application for types that do not support null values (such as
        <code class="classname">int</code>, <code class="classname">double</code>,
        <code class="classname">float</code>).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382096"></a>3.5.3.8.&nbsp;select</h4></div></div></div><p>The select attribute is used to describe a relationship between
        objects and to automatically load complex (i.e. user defined) property
        types. The value of the statement property must be the name of another
        mapped statement. The value of the database column (the column
        attribute) that is defined in the same property element as this
        statement attribute will be passed to the related mapped statement as
        the parameter. More information about supported primitive types and
        complex property mappings/relationships is discussed later in this
        document. The lazyLoad attribute can be specified with the
        select</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382118"></a>3.5.3.9.&nbsp;typeHandler</h4></div></div></div><p>The typeHandler attribute allows the use of a Custom Type
        Handler (see the Custom Type Handler section). This allows you to
        extend the DataMapper's capabilities in handling types that are
        specific to your database provider, are not handled by your database
        provider, or just happen to be a part of your application design. You
        can create custom type handlers to deal with storing and retrieving
        booleans and Guids from your database for example.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id382147"></a>3.5.4.&nbsp;&lt;result&gt; Elements</h3></div></div></div><p>The &lt;resultMap&gt; element holds one or more &lt;result&gt;
      child elements that map SQL resultsets to object properties.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382161"></a>3.5.4.1.&nbsp;property</h4></div></div></div><p>The <em class="parameter"><code>property</code></em> attribute is the name of a
        field or a property of the result object that will be returned by the Mapped
        Statement. The name can be used more than once depending on the number
        of times it is needed to populate the results.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382176"></a>3.5.4.2.&nbsp;column</h4></div></div></div><p>The <em class="parameter"><code>column</code></em> attribute value is the name of
        the column in the result set from which the value will be used to
        populate the property.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382193"></a>3.5.4.3.&nbsp;columnIndex</h4></div></div></div><p>As an optional (minimal) performance enhancement, the
        <em class="parameter"><code>columnIndex</code></em> attribute value is the index of the
        column in the ResultSet from which the value will be used to populate
        the object property. This is not likely needed in 99% of applications
        and sacrifices maintainability and readability for speed. Some
        providers may not realize any performance benefit, while others will
        speed up dramatically.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382216"></a>3.5.4.4.&nbsp;dbType</h4></div></div></div><p>The dbType attribute is used to explicitly specify the database
        column type of the ResultSet column that will be used to populate the
        object property. Although Result Maps do not have the same
        difficulties with null values, specifying the type can be useful for
        certain mapping types such as Date properties. Because an application
        language has one Date value type and SQL databases may have many
        (usually at least 3), specifying the date may become necessary in some
        cases to ensure that dates (or other types) are set correctly.
        Similarly, String types may be populated by a VarChar, Char or CLOB,
        so specifying the type might be needed in those cases too.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382226"></a>3.5.4.5.&nbsp;type</h4></div></div></div><p>The type attribute is used to explicitly specify the CLR
        property type of the parameter to be set. Normally this can be derived
        from a property through reflection, but certain mappings that use
        objects such as a Map cannot provide the type to the framework. If the
        attribute type is not set and the framework cannot otherwise determine
        the type, the type is assumed to be Object. Section 6 details the CLR
        types and available aliases that are supported by the
        framework.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382246"></a>3.5.4.6.&nbsp;resultMapping</h4></div></div></div><p>The <em class="parameter"><code>resultMapping</code></em> attribute can be set to
        the name of another resultMap used to fill the property. If the
        resultMap is in an other mapping file, you must specified the fully
        qualified name as : </p><pre class="programlisting">resultMapping="[namespace.sqlMap.]resultMappingId"

resultMapping="Newspaper"
<span class="comment">&lt;!--resultMapping with a fully qualified name.--&gt;</span>
resultMapping="LineItem.LineItem"
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382277"></a>3.5.4.7.&nbsp;nullValue</h4></div></div></div><p>The <em class="parameter"><code>nullValue</code></em> attribute can be set to any
        valid value (based on property type). The result element's
        <em class="parameter"><code>nullValue</code></em> attribute is used to specify an
        inbound null value replacement. What this means is that when the value
        is detected in a query's result column, the corresponding object
        property will be set to the the <em class="parameter"><code>nullValue</code></em>
        attribute's value. This allows you to use a "magic" null number in
        your application for types that do not support null values (such as
        <code class="classname">int</code>, <code class="classname">double</code>,
        <code class="classname">float</code>).</p><p>If your database has a NULLABLE column, but you want your
        application to represent NULL with a constant value, you can specify
        it in the Result Map as shown in Example 3.25.</p><div class="example"><a name="id382323"></a><p class="title"><b>Example&nbsp;3.28.&nbsp;Specifying a nullvalue attribute in a Result Map</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMap id="get-product-result" class="product"&gt; 
  &lt;result property="id" column="PRD_ID"/&gt;
  &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
  &lt;result property="subCode" column="PRD_SUB_CODE" <span class="blue">nullValue="-9999"</span>/&gt;
&lt;/resultMap&gt;</pre></div></div><br class="example-break"><p>In Example 3.25, if PRD_SUB_CODE is read as NULL, then the
        subCode property will be set to the value of -9999. This allows you to
        use a primitive type in your .NET class to represent a NULLABLE column
        in the database. Remember that if you want this to work for queries as
        well as updates/inserts, you must also specify the nullValue in the
        Parameter Map (discussed earlier in this document).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382359"></a>3.5.4.8.&nbsp;select</h4></div></div></div><p>The select attribute is used to describe a relationship between
        objects and to automatically load complex (i.e. user defined) property
        types. The value of the statement property must be the name of another
        mapped statement. The value of the database column (the column
        attribute) that is defined in the same property element as this
        statement attribute will be passed to the related mapped statement as
        the parameter. More information about supported primitive types and
        complex property mappings/relationships is discussed later in this
        document. The lazyLoad attribute can be specified with the
        select</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382381"></a>3.5.4.9.&nbsp;lazyLoad</h4></div></div></div><p>Use the lazyLoad attribute with the select attribute to indicate
        whether or not the select statement's results should be lazy loaded.
        This can provide a performance boost by delaying the loading of the
        select statement's results until they are needed/accessed.</p><p>Lazy loading is supported transparently for IList and IList&lt;T&gt; implementation.</p><p>Lazy
 loading is supported on strongly typed collection via 
Castle.DynamicProxy component. In this case you must set the listClass 
attribute and declare all methods/properties of the typed collection 
that you want to proxy as virtual.</p><p>Lazy loading is supported on 
concrete class via Castle.DynamicProxy component. In this case, you must
 declare all methods/properties of the class that you want to proxy as 
virtual.</p><p>
		</p><div class="example"><a name="id382419"></a><p class="title"><b>Example&nbsp;3.29.&nbsp;Sample of strongly typed collection used with proxy call</b></p><div class="example-contents"><pre class="programlisting">[C#]

[Serializable]
public class LineItemCollection : CollectionBase 
{
	public LineItemCollection() {}

	public virtual LineItem this[int index] 
	{
		get	{ return (LineItem)List[index]; }
		set { List[index] = value; }
	}

	public virtual int Add(LineItem value) 
	{
		return List.Add(value);
	}

	public virtual void AddRange(LineItem[] value) 
	{
		for (int i = 0;	i &lt; value.Length; i++) 
		{
			Add(value[i]);
		}
	}

	public virtual void AddRange(LineItemCollection value) 
	{
		for (int i = 0;	i &lt; value.Count; i++) 
		{
			Add(value[i]);
		}
	}

	public virtual bool Contains(LineItem value) 
	{
		return List.Contains(value);
	}

	public virtual void CopyTo(LineItem[] array, int index) 
	{
		List.CopyTo(array, index);
	}

	public virtual int IndexOf(LineItem value) 
	{
		return List.IndexOf(value);
	}
	
	public virtual void Insert(int index, LineItem value) 
	{
		List.Insert(index, value);
	}
	
	public virtual void Remove(LineItem value) 
	{
		List.Remove(value);
	}

	public new virtual int Count
	{
		get {return this.List.Count;}
	}
}
</pre></div></div><p><br class="example-break"> 
		</p><div class="example"><a name="id382474"></a><p class="title"><b>Example&nbsp;3.30.&nbsp;Concrete class</b></p><div class="example-contents"><pre class="programlisting">[C#]

[Serializable]
public class Person
{
...
	public virtual string Name
	{
		get {return _name;}
	}
...
}
</pre></div></div><p><br class="example-break"></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id382489"></a>3.5.4.10.&nbsp;typeHandler</h4></div></div></div><p>The typeHandler attribute allows the use of a Custom Type
        Handler (see the Custom Type Handler section). This allows you to
        extend the DataMapper's capabilities in handling types that are
        specific to your database provider, are not handled by your database
        provider, or just happen to be a part of your application design. You
        can create custom type handlers to deal with storing and retrieving
        booleans and Guids from your database for example.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id382510"></a>3.5.5.&nbsp;Custom Type Handlers</h3></div></div></div><p>A custom type handler allows you to extend the DataMapper's
      capabilities in handling types that are specific to your database
      provider, not handled by your database provider, or just happen to be
      part of your application design. The .NET DataMapper provides an
      interface, IBatisNet.DataMappers.TypeHandlers.ITypeHandlerCallback, for
      you to use in implementing your custom type handler.</p><div class="example"><a name="id382527"></a><p class="title"><b>Example&nbsp;3.31.&nbsp;ITypeHandlerCallback interface</b></p><div class="example-contents"><pre class="programlisting">using System.Data;
using IBatisNet.DataMapper.Configuration.ParameterMapping;


namespace IBatisNet.DataMapper.TypeHandlers
{
 public interface ITypeHandlerCallback
 {
  <span class="blue">void SetParameter(IParameterSetter setter, object parameter);</span>

  <span class="blue">object GetResult(IResultGetter getter);</span>

  <span class="blue">object ValueOf(string s);</span>
 }
}</pre></div></div><p><br class="example-break">The <code class="methodname">SetParameter</code> method allows you
      to process a &lt;statement&gt; parameter's value before it is added as
      an IDbCommand parameter. This enables you to do any necessary type
      conversion and clean-up before the DataMapper gets to work. If needed,
      you also have access to the underlying IDataParameter through the
      setter.DataParameter property.</p><p>The <code class="methodname">GetResult</code> method allows you to
      process a database result value right after it has been retrieved by the
      DataMapper and before it is used in your resultClass, resultMap, or
      listClass. If needed, you also have access to the underlying IDataReader
      through the getter.DataReader property.</p><p>The <code class="methodname">ValueOf</code> method allows you to compare
      a string representation of a value with one that you are expecting and
      can handle appropriately. Typically, this is useful for translating a
      null value, but if your application or database will not support a null
      value, you can basically return the given string. When presented with an
      unexpected value, you can throw an appropriate exception.</p><p>One scenario that is familiar to .NET developers is the handling
      of a Guid type/structure. Many providers do not handle Guid class
      properties well, and developers may be faced with littering their domain
      objects with an additional set of property accessors to translate Guid
      properties into strings and strings into Guids.</p><pre class="programlisting">public class BudgetObjectCode
{
 private string _code;
 private string _description;
 private Guid _guidProperty;

...

 public Guid GuidProperty {
  get { return _guidProperty; }
  set { _guidProperty = value; }
 }

 public string GuidPropertyString {
  get { return _guidProperty.ToString(); }
  set { 
  if (value == null) {
    _guidProperty = Guid.Empty;
   }
   else {
    _guidProperty = new Guid(value.ToString());
   }
  }
 }
...
}</pre><p>We can use a custom type handler to clean up this domain class.
      First, we define a string that will represent a null Guid value
      (Guid.Empty). We can then use that constant in our ValueOf null value
      comparison for the DataMapper to eventually use in setting our domain
      class' Guid properties. Implementing the GetResult and SetParameter
      methods is straightforward since we had been basically doing the same
      translation in our domain class' GuidPropertyString accessors.</p><div class="example"><a name="id382898"></a><p class="title"><b>Example&nbsp;3.32.&nbsp;Guid String Type Handler</b></p><div class="example-contents"><pre class="programlisting">using System;
using IBatisNet.DataMapper.TypeHandlers;

namespace BigApp.Common.TypeHandlers
{
 /// &lt;summary&gt;
 /// GuidVarcharTypeHandlerCallback.
 /// &lt;/summary&gt;
 public class GuidVarcharTypeHandlerCallback : ITypeHandlerCallback
 {
  private const string GUIDNULL = "00000000-0000-0000-0000-000000000000";

  public object ValueOf(string nullValue)
  {
   if (GUIDNULL.Equals(nullValue)) 
   {
    return Guid.Empty;
   } 
   else 
   {
    throw new Exception(
     "Unexpected value " + nullValue + 
     " found where "+GUIDNULL+" was expected to represent a null value.");
   }  
  }

  public object GetResult(IResultGetter getter)
  {
   try {
    Guid result = new Guid(getter.Value.ToString());
    return result;
   } 
   catch
   {
     throw new Exception(
     "Unexpected value " + getter.Value.ToString() + 
     " found where a valid GUID string value was expected.");
   }
  }

  public void SetParameter(IParameterSetter setter, object parameter)
  {
   setter.Value = parameter.ToString();
  }

 }
}</pre></div></div><p><br class="example-break"></p><p>With our custom type handler, we can clean up our domain class and
      use the handler in our SqlMaps. To do that, we have two options in
      configuring our custom type handler to be used by the DataMapper. We can
      simply add it as a &lt;typeAlias&gt; and use it when needed in a
      parameterMap or resultMap.</p><div class="example"><a name="id382958"></a><p class="title"><b>Example&nbsp;3.33.&nbsp;Aliased Custom Type Handler in a SqlMap.xml file</b></p><div class="example-contents"><pre class="programlisting">&lt;alias&gt;
 &lt;typeAlias alias="GuidVarchar" 
         type="BigApp.Common.TypeHandlers.GuidVarcharTypeHandlerCallback,
               BigApp.Common"/&gt;
&lt;/alias&gt;
 
&lt;resultMaps&gt;                                    
 &lt;resultMap id="boc-result"  class="BudgetObjectCode"&gt;
  &lt;result property="Code" column="BOC_CODE" dbType="Varchar2"/&gt;
  &lt;result property="Description" column="BOC_DESC" dbType="Varchar2"/&gt;
  &lt;result property="GuidProperty" column="BOC_GUID" typeHandler="GuidVarchar"/&gt;
 &lt;/resultMap&gt;
&lt;/resultMaps&gt;</pre></div></div><p><br class="example-break"></p><p>Or we can specify it as a basic &lt;typeHandler&gt; for all Guid
      types mapped in our SqlMap files. &lt;typeHandler&gt; in
      SqlMap.config</p><div class="example"><a name="id378138"></a><p class="title"><b>Example&nbsp;3.34.&nbsp;&lt;typeHandler&gt; in SqlMap.config</b></p><div class="example-contents"><pre class="programlisting"><span class="comment">[Our SqlMap.config]</span>
&lt;alias&gt;
 &lt;typeAlias <span class="blue">alias="GuidVarchar"</span> 
         type="BigApp.Common.TypeHandlers.GuidVarcharTypeHandlerCallback,
               BigApp.Common"/&gt;
&lt;/alias&gt;

&lt;typeHandlers&gt;
 &lt;typeHandler <span class="blue">type="guid"</span> dbType="Varchar2" <span class="blue">callback="GuidVarchar"</span>/&gt;
&lt;/typeHandlers&gt; 


<span class="comment">[One of our SqlMap.xml files]</span>
&lt;parameterMaps&gt;
 &lt;parameterMap id="boc-params"&gt;
  &lt;parameter property="Code" dbType="Varchar2" size="10"/&gt;
  &lt;parameter property="Description" dbType="Varchar2" size="100"/&gt;
  &lt;parameter property="GuidProperty" dbType="Varchar2" type="guid"/&gt;
 &lt;/parameterMap&gt;
&lt;/parameterMaps&gt;

&lt;resultMaps&gt;                                    
 &lt;resultMap id="boc-result"  class="BudgetObjectCode"&gt;
  &lt;result property="Code" column="BOC_CODE" dbType="Varchar2"/&gt;
  &lt;result property="Description" column="BOC_DESC" dbType="Varchar2"/&gt;
  &lt;result property="GuidProperty" column="BOC_GUID" dbType="Varchar2" <span class="blue">type="guid"</span>/&gt;
 &lt;/resultMap&gt;
&lt;/resultMaps&gt;</pre></div></div><p><br class="example-break"></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383030"></a>3.5.6.&nbsp;Inheritance Mapping</h3></div></div></div><p>The iBATIS DataMapper supports the implementation of
      object-oriented inheritance (subclassing) in your object model. There
      are several developer options for mapping entity classes and subclasses
      to database results:</p><div class="itemizedlist"><ul type="disc"><li>
             resultMap for each class 
          </li><li>
             resultMap with submaps for a class hierarchy 
          </li><li>
             resultMap with extended resultMaps for each subclass 
          </li></ul></div><p>You can use the most efficient mapping strategies from
      a SQL and query performance perspective when using the inheritance
      mappings of the DataMapper. To implement an inheritance mapping, the
      resultMap must define one or more columns in your query's resultset that
      will serve to identify which resultMap should be used to map each result
      record to a specific subclass. In many cases, you will use one column
      value for the DataMapper to use in identifying the proper resultMap and
      subclass. This column is known as a discriminator.</p><p>For example, we have a table defined in a database that contains
      Document records. There are five table columns used to store Document
      IDs, Titles, Types, PageNumbers, and Cities. Perhaps this table belongs
      to a legacy database, and we need to create an application using this
      table with a domain model that defines a class hierarchy of different
      types of Documents. Or perhaps we are creating a new application and
      database and just want to persist the data found in a set of related
      classes into one table. In either case, the DataMapper's inheritance
      mapping feature can help.</p><pre class="programlisting"><span class="comment">// Database table Document</span>
CREATE TABLE [Documents] (
    [Document_ID] [int] NOT NULL ,
    [Document_Title] [varchar] (32) NULL ,
    [Document_Type] [varchar] (32)  NULL ,
    [Document_PageNumber] [int] NULL  ,
    [Document_City] [varchar] (32)  NULL
)</pre><p>To illustrate this, let's take a look at a few example classes
      shown below that have a relationship through inheritance and whose
      properties can be persisted into our Documents table. First, we have a
      base Document class that has Id and Title properties. Next, we have a
      Book class that inherits from Document and contains an additional
      property called PageNumber. Last, we have a Newspaper class that also
      inherits from Document and contains a City property.</p><div class="example"><a name="id378221"></a><p class="title"><b>Example&nbsp;3.35.&nbsp;Documents, Books, and Newspapers!</b></p><div class="example-contents"><pre class="programlisting"><span class="comment">// C# class</span>
public class Document
{
  private int _id = -1;
  private string _title = string.Empty;

  public int Id
  {
    get { return _id; }
    set { _id = value; }
  }

  public string Title
  {
    get { return _title; }
    set { _title = value; }
  }
}

public class Book : Document
{
  private int _pageNumber = -1;

  public int PageNumber
  {
    get { return _pageNumber; }
    set { _pageNumber = value; }
  }
}

public class Newspaper : Document
{
  private string _city = string.Empty;

  public string City
  {
    get { return _city; }
    set { _city = value; }
  }
}</pre></div></div><p><br class="example-break">Now that we have our classes and database table, we can
      start working on our mappings. We can create one &lt;select&gt;
      statement that returns all columns in the table. To help the DataMapper
      discriminate between the different Document records, we're going to
      indicate that the Document_Type column holds values that will
      distinguish one record from another for mapping the results into our
      class hierarchy.</p><pre class="programlisting"><span class="comment">// Document mapping file</span>
&lt;select id="GetAllDocument" resultMap="document"&gt; 
   select 
     Document_Id, Document_Title, Document_Type,
     Document_PageNumber, Document_City
   from Documents 
   order by Document_Type, Document_Id
&lt;/select&gt;

&lt;resultMap <span class="blue">id="document"</span> class="Document"&gt; 
  &lt;result property="Id" column="Document_ID"/&gt;
  &lt;result property="Title" column="Document_Title"/&gt;
  <span class="blue">&lt;discriminator column="Document_Type" type="string"/&gt;
  &lt;subMap value="Book" resultMapping="book"/&gt;
  &lt;subMap value="Newspaper" resultMapping="newspaper"/&gt;</span>
&lt;/resultMap&gt;

&lt;resultMap id="book" class="Book" <span class="blue">extends="document"</span>&gt; 
  &lt;property="PageNumber" column="Document_PageNumber"/&gt;
&lt;/resultMap&gt;

&lt;resultMap id="newspaper" class="Newspaper"  <span class="blue">extends="document"</span>&gt; 
  &lt;property="City" column="Document_City"/&gt;
&lt;/resultMap&gt;</pre><p>The DataMapper compares the data found in the discriminator column
      to the different &lt;submap&gt; values using the column value's string
      equivalence. Based on this string value, iBATIS DataMapper will use the
      resultMap named "Book" or "Newspaper" as defined in the &lt;submap&gt;
      elements or it will use the "super" resultMap "Document" if neither of
      the submap values satisfy the comparison. With these resultMaps, we can
      implement an object-oriented inheritance mapping to our database
      table.</p><p>If you want to use custom logic, you can use the typeHandler
      attribute of the &lt;discriminator&gt; element to specify a custom type
      handler for the discriminator column.</p><div class="example"><a name="id383143"></a><p class="title"><b>Example&nbsp;3.36.&nbsp;Complex disciminator usage with Custom Type Handler</b></p><div class="example-contents"><pre class="programlisting"><span class="blue">&lt;alias&gt;
  &lt;typeAlias alias="CustomInheritance" 
  type="IBatisNet.DataMapper.Test.Domain.CustomInheritance, IBatisNet.DataMapper.Test"/&gt;
&lt;/alias&gt;</span>

&lt;resultMaps&gt;
  &lt;resultMap id="document-custom-formula" class="Document"&gt;
    &lt;result property="Id" column="Document_ID"/&gt;
    &lt;result property="Title" column="Document_Title"/&gt;
    &lt;discriminator <span class="blue">column="Document_Type" typeHandler="CustomInheritance"</span>/&gt;
    &lt;subMap value="Book" resultMapping="book"/&gt;
    &lt;subMap value="Newspaper" resultMapping="newspaper"/&gt;
  &lt;/resultMap&gt;
&lt;/resultMaps&gt;</pre></div></div><br class="example-break"><p>The value of the typeHandler attribute specifies which of our
      classes implements the <span class="blue">ITypeHandlerCallback</span> interface. This interface
      furnishes a GetResult method for coding custom logic to read the column
      result value and return a value for the DataMapper to use in its
      comparison to the resultMap's defined &lt;submap&gt; values.</p><div class="example"><a name="id383196"></a><p class="title"><b>Example&nbsp;3.37.&nbsp;Example ITypeHandlerCallback interface implementation</b></p><div class="example-contents"><pre class="programlisting">public class CustomInheritance : ITypeHandlerCallback
{
  #region ITypeHandlerCallback members

  public object ValueOf(string nullValue)
  {
    throw new NotImplementedException();
  }

  public object GetResult(IResultGetter getter)
  {
   string type = getter.Value.ToString();

   if (type=="Monograph" || type=="Book")
   {
     return "Book";
   }
   else if (type=="Tabloid" || type=="Broadsheet" || type=="Newspaper")
   {
     return "Newspaper";
   }
   else
   {
     return "Document";
   }

  }

  public void SetParameter(IParameterSetter setter, object parameter)
  {
   throw new NotImplementedException(); 
  }
  #endregion
}</pre></div></div><br class="example-break"></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383220"></a>3.5.7.&nbsp;Implicit Result Maps</h3></div></div></div><p>If the columns returned by a SQL statement match the result
      object, you may not need an explicit Result Map. If you have control
      over the relational schema, you might be able to name the columns so
      they also work as property names. In Example 3.33, the column names and
      property names already match, so a result map is not needed.</p><div class="example"><a name="id383234"></a><p class="title"><b>Example&nbsp;3.38.&nbsp;A Mapped Statement that doesn't need a Result Map</b></p><div class="example-contents"><pre class="programlisting">&lt;statement id="selectProduct" resultClass="Product"&gt;
  select
    id,
    description
  from PRODUCT
  where id = #value#
&lt;/statement&gt;</pre></div></div><p><br class="example-break"></p><p>Another way to skip a result map is to use column aliasing to make
      the column names match the properties names, as shown in Example
      3.34.</p><div class="example"><a name="id383260"></a><p class="title"><b>Example&nbsp;3.39.&nbsp;A Mapped Statement using column alaising instead of a Result
        Map</b></p><div class="example-contents"><pre class="programlisting">&lt;statement id="selectProduct" resultClass="Product"&gt;
  select
  PRD_ID as <span class="blue">id</span>,
  PRD_DESCRIPTION as <span class="blue">description</span>
  from PRODUCT
  where PRD_ID = #value#
&lt;/statement&gt;</pre></div></div><br class="example-break"><p>Of course, these techniques will not work if you need to specify a
      column type, a null value, or any other property attributes.</p><p>Case sensitivity can also be an issue with implicit result maps.
      Conceivably, you could have an object with a "FirstName" property and a
      "Firstname" property. When iBATIS tries to match property and column,
      the heurstic is case-insensitive and we cannot guarantee which property
      would match. (Of course, very few developers would have two property
      names that were so simiilar.)</p><p>A final issue is that there is some performance overhead when
      iBATIS has to map the column and property names automatically. The
      difference can be dramatic if using a third-party NET database provider
      with poor support for ResultSetMetaData.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383312"></a>3.5.8.&nbsp;Primitive Results (i.e. String, Integer, Boolean)</h3></div></div></div><p>Many times, we don't need to return an object with multiple
      properties. We just need a String, Integer, Boolean, and so forth. If
      you don't need to populate an object, iBATIS can return one of the
      primitive types instead. If you just need the value, you can use a
      standard type as a result class, as shown in Example 3.35.</p><div class="example"><a name="id383327"></a><p class="title"><b>Example&nbsp;3.40.&nbsp;Selecting a standard type</b></p><div class="example-contents"><pre class="programlisting">&lt;select id="selectProductCount" resultClass="<span class="blue">System.Int32</span>"&gt;
  select count(1)
  from PRODUCT
&lt;/select&gt;</pre></div></div><p><br class="example-break"></p><p>If need be, you can refer to the standard type using a marker
      token, "value", as shown by Example 3.36.</p><div class="example"><a name="id383354"></a><p class="title"><b>Example&nbsp;3.41.&nbsp;Loading a simple list of product descriptions</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMap id="select-product-result" resultClass="System.String"&gt;
  &lt;result property="<span class="blue">value</span>" column="PRD_DESCRIPTION"/&gt;
&lt;/resultMap&gt;</pre></div></div><br class="example-break"></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383376"></a>3.5.9.&nbsp;Maps with ResultMaps</h3></div></div></div><p>Instead of a rich object, sometimes all you might need is a simple
      key/value list of the data, where each property is an entry on the list.
      If so, Result Maps can populate a IDictionary instance as easily as
      property objects. The syntax for using a IDictionary is identical to the
      rich object syntax. As shown in Example 3.37, only the result object
      changes.</p><div class="example"><a name="id383392"></a><p class="title"><b>Example&nbsp;3.42.&nbsp;Result Maps can use generic "entry-type" objects</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMap id="select-product-result" class="<span class="blue">HashTable</span>"&gt;
  &lt;result property="id" column="PRD_ID"/&gt;
  &lt;result property="code" column="PRD_CODE"/&gt;
  &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
  &lt;result property="suggestedPrice" column="PRD_SUGGESTED_PRICE"/&gt;
&lt;/resultMap&gt;</pre></div></div><br class="example-break"><p>In Example 3.37, an instance of HashTable would be created for
      each row in the result set and populated with the Product data. The
      property name attributes, like <em class="parameter"><code>id</code></em>,
      <em class="parameter"><code>code</code></em>, and so forth, would be the key of the
      entry, and the value of the mapped columns would be the value of the
      entry.</p><p>As shown in Example 3.38, you can also use an implicit Result Map
      with a IDictionary type.</p><div class="example"><a name="id383440"></a><p class="title"><b>Example&nbsp;3.43.&nbsp;Implicit Result Maps can use "entry-type" objects too</b></p><div class="example-contents"><pre class="programlisting">&lt;statement id="selectProductCount" resultClass="<span class="blue">HashTable</span>"&gt;
  select * from PRODUCT
&lt;/statement&gt;</pre></div></div><br class="example-break"><p>What set of entries is returned by Example xx depends on what
      columns are in the result set. If the set of column changes (because
      columns are added or removed), the new set of entries would
      automatically be returned.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="3.5.%C2%A0Result%20Maps%20Archivos/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Certain providers may return column names in upper case or
          lower case format. When accessing values with such a provider, you
          will have to pass the Hashtable or HashMap key name in the expected
          case.</p></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383480"></a>3.5.10.&nbsp;Complex Properties</h3></div></div></div><p>In a relational database, one table will often refer to another.
      Likewise, some of your business objects may include another object or
      list of objects. Types that nest other types are called "complex types".
      You may not want a statement to return a simple type, but a fully-formed
      compex type.</p><p>In the database, a related column is usually represented via a 1:1
      relationship, or a 1:M relationship where the class that holds the
      complex property is from the "many side" of the relationship and the
      property itself is from the "one side" of the relationship. The column
      returned from the database will not be the property we want; it is a key
      to be used in another query.</p><p>From the framework's perspective, the problem is not so much
      loading a complex type, but loading each "complex property". To solve
      this problem, you can specify in the Result Map a statement to run to
      load a given property. In Example 3.39, the "category" property of the
      "select-product-result" element is a complex property. </p><div class="example"><a name="id383514"></a><p class="title"><b>Example&nbsp;3.44.&nbsp;A Result Map with a Complex Property</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMaps&gt;
  &lt;resultMap id="select-product-result" class="product"&gt;
    &lt;result property="id" column="PRD_ID"/&gt;
    &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
    <span class="blue">&lt;result property="category" column="PRD_CAT_ID" select="selectCategory"/&gt;</span>
  &lt;/resultMap&gt;

  &lt;resultMap id="select-category-result" class="category"&gt;
    &lt;result property="id" column="CAT_ID"/&gt;
    &lt;result property="description" column="CAT_DESCRIPTION"/&gt;
  &lt;/resultMap&gt;
&lt;/resultMaps&gt;

&lt;statements&gt;
  &lt;select id="selectProduct" parameterClass="int" resultMap="select-product-result"&gt;
   select * from PRODUCT where PRD_ID = #value#
  &lt;/select&gt;

  &lt;select id="selectCategory" parameterClass="int" resultMap="select-category-result"&gt;
   <span class="blue">select * from CATEGORY where CAT_ID = #value#</span>
  &lt;/select&gt;
&lt;/statements&gt;
      </pre></div></div><p><br class="example-break"> In Example 3.39, the framework will use the
      "selectCategory" statement to populate the "category" property. The
      value of each category is passed to the "selectCategory" statement, and
      the object returned is set to the category property. When the process
      completes, each Product instance will have the the appropriate category
      object instance set.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383575"></a>3.5.11.&nbsp;Avoiding N+1 Selects (1:1)</h3></div></div></div><p>A problem with Example 3.39 may be that whenever you load a
      Product, two statements execute: one for the Product and one for the
      Category. For a single Product, this issue may seem trivial. But if you
      load 10 products, then 11 statements execute. For 100 Products, instead
      of one statement product statement executing, a total of 101 statements
      execute. The number of statements executing for Example 3.40 will always
      be N+1: 100+1=101.</p><div class="example"><a name="id383593"></a><p class="title"><b>Example&nbsp;3.45.&nbsp;N+1 Selects (1:1)</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMaps&gt;
  &lt;resultMap id="select-product-result" class="product"&gt;
    &lt;result property="id" column="PRD_ID"/&gt;
    &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
    <span class="blue">&lt;result property="category" column="PRD_CAT_ID" select="selectCategory"/&gt;</span>
  &lt;/resultMap&gt;

  &lt;resultMap id="select-category-result" class="category"&gt;
    &lt;result property="id" column="CAT_ID"/&gt;
    &lt;result property="description" column="CAT_DESCRIPTION"/&gt;
  &lt;/resultMap&gt;
&lt;/resultMaps&gt;

&lt;statements&gt;
  <span class="comment">&lt;!-- This statement executes 1 time --&gt;</span>
  &lt;select id="selectProducts" parameterClass="int" resultMap="select-product-result"&gt;
   select * from PRODUCT
  &lt;/select&gt;

  <span class="comment">&lt;!-- This statement executes N times (once for each product returned above) --&gt;</span>
  &lt;select id="selectCategory" parameterClass="int" resultMap="select-category-result"&gt;
   <span class="blue">select * from CATEGORY where CAT_ID = #value#</span>
  &lt;/select&gt;
&lt;/statements&gt;
      </pre></div></div><br class="example-break"><p>One way to mitigate the problem is to cache the "selectCategory"
      statement . We might have a hundred products, but there might only be
      five categories. Instead of running a SQL query or stored procedure, the
      framework will return the category object from it cache. A 101
      statements would still run, but they would not be hitting the database.
      (See Section 3.8 for more about caches.)</p><p>Another solution is to use a standard SQL join to return the
      columns you need from the another table. A join can bring all the
      columns we need over from the database in a single query. When you have
      a nested object, you can reference nested properties using a dotted
      notation, like "category.description".</p><p>Example 3.41 solves the same problem as Example 3.40, but uses a
      join instead of nested properties.</p><div class="example"><a name="id383677"></a><p class="title"><b>Example&nbsp;3.46.&nbsp;Resolving complex properties with a join</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMaps&gt;
  &lt;resultMap id="select-product-result" class="product"&gt;
    &lt;result property="id" column="PRD_ID"/&gt;
    &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
    <span class="blue">&lt;result property="category" resultMapping="Category.CategoryResult" /&gt;</span>
  &lt;/resultMap&gt;
&lt;/resultMaps&gt;

&lt;statements&gt;
  &lt;statement id="selectProduct" parameterClass="int" resultMap="select-product-result"&gt;
    select *
    from PRODUCT, CATEGORY
    where PRD_CAT_ID=CAT_ID
    and PRD_ID = #value#
  &lt;/statement&gt;
&lt;/statements&gt;
      </pre></div></div><br class="example-break"><div class="sidebar"><p class="title"><b></b></p><p><span class="emphasis"><em>Lazy Loading vs. Joins (1:1)</em></span></p><p>It's important to note that using a join is not always better.
        If you are in a situation where it is rare to access the related
        object (e.g. the category property of the Product class) then it might
        actually be faster to avoid the join and the unnecessary loading of
        all category properties. This is especially true for database designs
        that involve outer joins or nullable and/or non-indexed columns. In
        these situations it might be better to use the sub-select solution
        with lazy loading enabled. The general rule of thumb is: use the join
        if you're more likely going to access the associated properties than
        not. Otherwise, only use it if lazy loading is not an option.</p><p>If you're having trouble deciding which way to go, don't worry.
        No matter which way you go, you can always change it without impacting
        your application source code. Example 3.40 and 3.41 result in exactly
        the same object graph and are loaded using the exact same method call
        from the application. The only consideration is that if you were to
        enable caching, then the using the separate select (not the join)
        solution could result in a cached instance being returned. But more
        often than not, that won't cause a problem (your application shouldn't
        be dependent on instance level equality i.e. "==").</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383729"></a>3.5.12.&nbsp;Complex Collection Properties</h3></div></div></div><p>It is also possible to load properties that represent lists of
      complex objects. In the database the data would be represented by a M:M
      relationship, or a 1:M relationship where the class containing the list
      is on the "one side" of the relationship and the objects in the list are
      on the "many side". To load an IList of objects, there is no change to
      the statement (see example above). The only difference required to cause
      the iBATIS DataMapper framework to load the property as an IList is that
      the property on the business object must be of type
      System.Collections.IList. For example, if a Category has a IList of
      Product instances, the mapping would look like this (assuming Category
      has a property called "ProductList" of
      System.Collections.IList.):</p><div class="example"><a name="id383753"></a><p class="title"><b>Example&nbsp;3.47.&nbsp;Mapping that creates a list of complex objects</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMaps&gt;

  &lt;resultMap id="select-category-result" class="Category"&gt;
    &lt;result property="Id" column="CAT_ID"/&gt;
    &lt;result property="Description" column="CAT_DESCRIPTION"/&gt;
    <span class="blue">&lt;result property="ProductList" column="CAT_ID" select="selectProductsByCatId"/&gt;</span>
  &lt;/resultMap&gt;

  &lt;resultMap id="select-product-result" class="Product"&gt;
    &lt;result property="Id" column="PRD_ID"/&gt;
    &lt;result property="Description" column="PRD_DESCRIPTION"/&gt;
  &lt;/resultMap&gt;
&lt;resultMaps&gt;

&lt;statements&gt;

  &lt;statement id="selectCategory" parameterClass="int" resultMap="select-category-result"&gt;
    select * from CATEGORY where CAT_ID = #value#
  &lt;/statement&gt;

  &lt;statement id="selectProductsByCatId" parameterClass="int" resultMap="select-product-result"&gt;
    <span class="blue">select * from PRODUCT where PRD_CAT_ID = #value#</span>
  &lt;/statement&gt;
&lt;/statements&gt;</pre></div></div><br class="example-break"></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id383806"></a>3.5.13.&nbsp;Avoiding N+1 Select Lists (1:M and M:N)</h3></div></div></div><p>This is similar to the 1:1 situation above, but is of even greater
      concern due to the potentially large amount of data involved. The
      problem with the solution above is that whenever you load a Category,
      two SQL statements are actually being run (one for the Category and one
      for the list of associated Products). This problem seems trivial when
      loading a single Category, but if you were to run a query that loaded
      ten (10) Categories, a separate query would be run for each Category to
      load its associated list of Products. This results in eleven (11)
      queries total: one for the list of Categories and one for each Category
      returned to load each related list of Products (N+1 or in this case
      10+1=11). To make this situation worse, we're dealing with potentially
      large lists of data.</p><div class="example"><a name="id383831"></a><p class="title"><b>Example&nbsp;3.48.&nbsp;N+1 Select Lists (1:M and M:N), example of problem</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMaps&gt;

  &lt;resultMap id="select-category-result" class="Category"&gt;
    &lt;result property="Id" column="CAT_ID"/&gt;
    &lt;result property="Description" column="CAT_DESCRIPTION"/&gt;
   <span class="blue">&lt;result property="ProductList" column="CAT_ID" select="selectProductsByCatId"/&gt;</span>
  &lt;/resultMap&gt;

  &lt;resultMap id="Product-result" class="Product"&gt;
    &lt;result property="Id" column="PRD_ID"/&gt;
    &lt;result property="Description" column="PRD_DESCRIPTION"/&gt;
  &lt;/resultMap&gt;
&lt;resultMaps&gt;

&lt;statements&gt;

  <span class="comment">&lt;!-- This statement executes 1 time --&gt;</span>
  &lt;statement id="selectCategory" parameterClass="int" resultMap="select-category-result"&gt;
    select * from CATEGORY where CAT_ID = #value#
  &lt;/statement&gt;

  <span class="comment">&lt;!-- This statement executes N times (once for each category returned above) 
       and returns a list of Products (1:M) --&gt;</span>
  &lt;statement id="selectProductsByCatId" parameterClass="int" resultMap="select-product-result"&gt;
    <span class="blue">select * from PRODUCT where PRD_CAT_ID = #value#</span>
  &lt;/statement&gt;
&lt;/statements&gt;</pre></div></div><br class="example-break"><p>iBATIS fully solves the N+1 selects problem. Here is the same example solved :</p><div class="example"><a name="id383900"></a><p class="title"><b>Example&nbsp;3.49.&nbsp;N+1 Select Lists (1:M and M:N) resolution</b></p><div class="example-contents"><pre class="programlisting">&lt;sqlMap namespace="ProductCategory"&gt;
&lt;resultMaps&gt;

  &lt;resultMap id="Category-result" class="Category" <span class="blue">groupBy="Id"</span>&gt;
    &lt;result property="Id" column="CAT_ID"/&gt;
    &lt;result property="Description" column="CAT_DESCRIPTION"/&gt;
    <span class="blue">&lt;result property="ProductList" resultMapping="ProductCategory.Product-result"/&gt;</span>
  &lt;/resultMap&gt;

  &lt;resultMap id="Product-result" class="Product"&gt;
    &lt;result property="Id" column="PRD_ID"/&gt;
    &lt;result property="Description" column="PRD_DESCRIPTION"/&gt;
  &lt;/resultMap&gt;
&lt;resultMaps&gt;

&lt;statements&gt;

  <span class="comment">&lt;!-- This statement executes 1 time --&gt;</span>
  &lt;statement id="SelectCategory" parameterClass="int" resultMap="Category-result"&gt;
    select C.CAT_ID, C.CAT_DESCRIPTION, P.PRD_ID, P.PRD_DESCRIPTION
    from CATEGORY C
    left outer join PRODUCT P
    on C.CAT_ID = P.PRD_CAT_ID
    where CAT_ID = #value#
  &lt;/statement&gt;

</pre></div></div><br class="example-break"><p>When you call...</p><pre class="programlisting">IList myList = sqlMap.QueryForList("SelectCategory", 1002);</pre><p>...the main query is executed, and the results are stored in the myList variable containing .NET type
"Category" element . Each object in that List will have a "ProductList" property that is also a List
populated from the same query, but using the "Product-result" result map to populate the element in the child
list. So, you end up with a list containing sub-lists, and only one database query is executed.</p><p>The important items here are the...</p><p><span class="term"><span class="blue">groupBy="Id"</span></span></p><p>...attribute and the...</p><p><span class="term">&lt;result property="ProductList" <span class="blue">resultMapping="ProductCategory.Product-result"</span>/&gt;</span></p><p>...property mapping in the "Category-result" result map. One other important detail is that the result mapping
for the ProductList property is namespace aware - had it been simply "Product-result" it would not work.
Using this approach, you can solve any N+1 problem of any depth or breadth.</p><div class="sidebar"><p class="title"><b></b></p><p><span class="emphasis"><em>Lazy Loading vs. Joins (1:M and M:N)</em></span></p><p>As with the 1:1 situation described previously, it's important
        to note that using a join is not always better. This is even more true
        for collection properties than it was for individual value properties
        due to the greater amount of data. If you are in a situation where it
        is rare to access the related object (e.g. the ProductList property of
        the Category class) then it might actually be faster to avoid the join
        and the unnecessary loading of the list of products. This is
        especially true for database designs that involve outer joins or
        nullable and/or non-indexed columns. In these situations it might be
        better to use the sub-select solution with the lazy loading. The
        general rule of thumb is: use the join if you're more likely going to
        access the associated properties than not. Otherwise, only use it if
        lazy loading is not an option.</p><p>As mentioned earlier, if you're having trouble deciding which
        way to go, don't worry. No matter which way you go, you can always
        change it without impacting your .NET code. The two examples above
        would result in exactly the same object graph and are loaded using the
        exact same method call. The only consideration is that if you were to
        enable caching, then the using the separate select (not the join)
        solution could result in a cached instance being returned. But more
        often than not, that won't cause a problem (your application should
        not be dependent on instance level equality i.e. "==").</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id384072"></a>3.5.14.&nbsp;Composite Keys or Multiple Complex Parameters Properties</h3></div></div></div><p>You might have noticed that in the above examples there is only a
      single key being used as specified in the resultMap by the column
      attribute. This would suggest that only a single column can be
      associated to a related mapped statement. However, there is an alternate
      syntax that allows multiple columns to be passed to the related mapped
      statement. This comes in handy for situations where a composite key
      relationship exists, or even if you simply want to use a parameter of
      some name other than #value#. The alternate syntax for the column
      attribute is simply {param1=column1, param2=column2, , paramN=columnN}.
      Consider the example below where the PAYMENT table is keyed by both
      Customer ID and Order ID:</p><div class="example"><a name="id384108"></a><p class="title"><b>Example&nbsp;3.50.&nbsp;Mapping a composite key</b></p><div class="example-contents"><pre class="programlisting">&lt;resultMaps&gt;
  &lt;resultMap id="select-order-result" class="order"&gt;
    &lt;result property="id" column="ORD_ID"/&gt;
    &lt;result property="customerId" column="ORD_CST_ID"/&gt;
    ...
    &lt;result property="payments" column="<span class="blue">itemId=ORD_ID, custId=ORD_CST_ID</span>"
      select="<span class="blue">selectOrderPayments"</span>/&gt;
  &lt;/resultMap&gt;
&lt;resultMaps&gt;

&lt;statements&gt;

  &lt;statement id="<span class="blue">selectOrderPayments</span>" resultMap="select-payment-result"&gt;
    select * from PAYMENT
    where PAY_ORD_ID = #<span class="blue">itemId</span>#
    and PAY_CST_ID = #<span class="blue">custId</span>#
  &lt;/statement&gt;
&lt;/statements&gt;</pre></div></div><br class="example-break"><p>Optionally you can just specify the column names as long as
      they're in the same order as the parameters. For example:</p><div class="informalexample"><pre class="programlisting"><span class="blue">ORD_ID, ORD_CST_ID</span></pre></div><p>As usual, this is a slight performance gain with an impact on
      readability and maintainability.</p><p>Important! Currently the iBATIS DataMapper framework does not
      automatically resolve circular relationships. Be aware of this when
      implementing parent/child relationships (trees). An easy workaround is
      to simply define a second result map for one of the cases that does not
      load the parent object (or vice versa), or use a join as described in
      the "N+1 avoidance" solutions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table summary="Note" border="0"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="3.5.%C2%A0Result%20Maps%20Archivos/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Result Map names are always local to the Data Map definition
          file that they are defined in. You can refer to a Result Map in
          another Data Map definition file by prefixing the name of the Result
          Map with the namespace of the SqlMap set in the &lt;sqlMap&gt; root
          element.</p></td></tr></tbody></table></div></div></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tbody><tr><td align="left" width="40%"><a accesskey="p" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03s04.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="https://ibatis.apache.org/docs/dotnet/datamapper/ch03s06.html">Next</a></td></tr><tr><td align="left" valign="top" width="40%">3.4.&nbsp;Parameter Maps and Inline Parameters&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="https://ibatis.apache.org/docs/dotnet/datamapper/index.html">Home</a></td><td align="right" valign="top" width="40%">&nbsp;3.6.&nbsp;Supported Types for Parameter Maps and Result Maps</td></tr></tbody></table></div>
</body></html>